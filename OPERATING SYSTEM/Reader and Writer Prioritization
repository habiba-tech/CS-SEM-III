import threading
import time
import random

#Semaphores
mutex = threading.Semaphore(1) #Protects rc
db = threading.Semaphore(1) #Controls database access to shared data

#Shared resource and reader count
shared_data = 0
rc = 0
running = True # Stop flag

def reader(reader_id):
    global rc, shared_data,running
    while running:
        # Entry section
        mutex.acquire()
        rc += 1
        if rc == 1:
            db.acquire() # First reader locks the database (Decrease)
        mutex.release()

        # Critical section
        print(f"Reader {reader_id} reads: {shared_data}")
        time.sleep(random.uniform(0.2, 0.5)) # Simulate reading time

        # Exit section
        mutex.acquire()
        rc -= 1
        if rc == 0:
            db.release() # Last reader unlocks the database (Increase)
        mutex.release()

        # Pausae before next read
        time.sleep(random.uniform(0.5, 1.0)) # Simulate time between reads

def writer(writer_id):
    global shared_data
    while running:
        # Entry section
        db.acquire() # Exclusive access 

        # Critical section
        shared_data += 1
        print(f"Writer {writer_id} writers {shared_data}")
        time.sleep(random.uniform(0.3,0.6)) # Simulate writing time

        # Exit section
        db.release() # Writer unlocks the database (Increase)

        # Pause before next write
        time.sleep(random.uniform(0.8,1.5)) # Simulate time between writes

if __name__ == "__main__":
    readers = [threading.Thread(target=reader, args=(i,)) for i in range(3)]
    writers = [threading.Thread(target=writer, args=(i,)) for i in range(2)]

    for r in readers:
        r.start()
    for w in writers:
        w.start()

    # Let the threads run for a while
    time.sleep(10)
    running = False # Stop all threads

    for r in readers:
        r.join()
    for w in writers:
        w.join()

    print("Final value of shared data:", shared_data)
